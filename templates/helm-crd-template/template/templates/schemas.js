import { File } from "@asyncapi/generator-react-sdk";
import { schema } from "@neuron/asyncapi-template-lib";
import yaml from "js-yaml";
import ejs from "ejs";

const resource = `
# This file was generated by asyncapi-generator.
# Any changes will be overwritten.

apiVersion: neuron.isf/v1alpha1
kind: NeuronSchema
metadata:
  name: <%= schemaName %>
spec:
  neuronClusterName: "{{ .Values.neuron.clusterName }}"
  tenant: <%= tenantName %>
  namespace: <%= namespaceName %>
  topic: <%= schemaName %>
  type: <%= type %>
  schema:
    <%- toYaml(schema, 4) %>
  <%_ if (contact.name || contact.email) { -%>
  properties:
    <%_ if (contact.name) { -%>
    owner: <%= contact.name %>
    <%_ } -%>
    <%_ if (contact.email) { -%>
    email: <%= contact.email %>
    <%_ } -%>
    <%_ if (contact.url) { -%>
    url: <%= contact.url %>
    <%_ } -%>
    {{- with (( index (.Values.neuron.schemas | default dict) "<%= schemaName %>" ).properties) }}
    {{- toYaml . | nindent 4 }}
    {{- end }}
  <%_ } else { -%>
  {{- with (( index (.Values.neuron.schemas | default dict) "<%= schemaName %>" ).properties) }}
  properties:
    {{- toYaml . | nindent 4 }}
  {{- end }}
  <%_ } -%>
`;

export default function ({ asyncapi }) {
  const schemas = fetchSchemas(asyncapi);

  const contact = {};
  if (asyncapi.info().contact()) {
    contact.name = asyncapi.info().contact().name();
    contact.email = asyncapi.info().contact().email();
    contact.url = asyncapi.info().contact().url();
  }

  return schemas.map(([name, data]) => {
    const filename = `${name}-schema.yaml`;
    const env = {
      schemaName: name,
      tenantName: data.tenant,
      namespaceName: data.namespace,
      type: data.type,
      schema: data.schema,
      contact,
      // Helper function to use inside the template
      // to render the schema to yaml
      toYaml: (d, indent = 0) => {
        return yaml
          .dump(d)
          .split("\n") // Split string on newlines
          .map(line => " ".repeat(indent) + line) // Add indentation to all lines
          .join("\n") // Join string together again
          .trim(); // Trim whitespace in first line (unindent)
      },
    };

    return <File name={filename}>{ejs.render(resource, env).trim()}</File>;
  });
}

function fetchSchemas(asyncapi) {
  const channels = asyncapi._json.channels;
  const messages = new Map();

  // Pull out all schemas from channels
  for (const channel in channels) {
    if (typeof channel === "string") {
      const parts = channel.split("/");
      const tenant = parts[0];
      const namespace = parts[1];
      const topic = parts[2];

      const c = asyncapi.channel(channel);
      if (c.hasSubscribe()) {
        const msgs = c.subscribe().messages();
        for (const m of msgs) {
          messages.set(topic, {
            tenant,
            namespace,
            message: m,
          });
        }
      }
      if (c.hasPublish()) {
        const msgs = c.publish().messages();
        for (const m of msgs) {
          messages.set(topic, {
            tenant,
            namespace,
            message: m,
          });
        }
      }
    }
  }

  return [...messages].map(convertAvroSchema);
}

function convertAvroSchema([name, { tenant, namespace, message }]) {
  const type = message.contentType().toLowerCase().includes("avro")
    ? "AVRO"
    : "JSON";
  // If the message has a `x-parser-original-schema-format`
  // and that value includes the string `avro` we assume
  // the original payload was an avro schema and pull that
  // out instead.
  if (message.originalSchemaFormat().includes("avro")) {
    const avro = message.originalPayload();
    return [
      name,
      {
        tenant,
        namespace,
        type,
        schema: avro,
      },
    ];
  } else {
    // Otherwise we normalize the the jsonschema payload
    // to try to infer schema names and then convert it to
    // avro schema.
    const normalized = schema.normalize(message.payload().json());
    const avroized = schema.jsonSchemaToAvro(normalized);
    return [
      name,
      {
        tenant,
        namespace,
        type,
        schema: avroized,
      },
    ];
  }
}
